# Random Number Generator (RNG) 

The Random Number Generator (RNG) algorithm for the original-games engine is designed to generate a deterministic stream of bytes based on these given input parameters: `serverSeed`, `clientSeed`, `nonce`, and `cursor`. This algorithm leverages HMAC-SHA256 hashing to produce a pseudo-random sequence of bytes. These bytes could then be cast to floating point values. This is the basis of the number generator of any game built on top of this engine. 

The RNG algorithm for the original-games engine is developed in Go  (part of the [`gameservice` app](/../gameservice/readme.md))  and it utilizes `crypto/hmac` & `crypto/sha256` from Go's standard library in order to produce the randomly generated bytes. This algorithm is exclusively invoked every time a random event occurs in any game built with this engine.

As stated, the RNG algorithm requires these 4 input parameters:

- `serverSeed`: A string acting as the key for the HMAC function.
- `clientSeed`: A user-defined string that, along with `nonce` and `currentRound`, forms the message to be hashed.
- `nonce`: An integer used to introduce uniqueness in the hash computation. Used to randomize different rounds for a given server seed and client seed for a particular player.
- `cursor`: An integer indicating the starting position in the 32 byte output from the HMAC function.

The latter 3 values are merged into a single 'message' and written into the HMAC function and the final hash (as byte stream) is computed. The algorithm streams 4 bytes at a time. 4 bytes being the amount required to build a 32-bit random floating point value. Therefore, each stream of 4 bytes is equivalent to a single random number. 

The algorithm allows for an infinite byte stream starting from `cursor`, which is crucial for games which require many random events in a single round. If the full 32-byte output of the HMAC-SHA256 function are utilised within a single round, the HMAC function is invoked again and algorithm starts reading from cursor position again.

This approach is provably fair. Which means that given a server seed, client seed & nonce, any game round can be reproducible. Since the client seed is completely controlled by the player & can be changed anytime (except during a game), the casino does not have the ability to tamper with the RNG or the game outcome in general.

Below is the Random Number Generator function:


```go
// byteGenerator generates a `count` amount of bytes based 
// on the provided seeds and nonce starting at position `cursor`.
func byteGenerator(serverSeed string, clientSeed string, nonce, cursor, count int) chan byte {
	ch := make(chan byte, 64)
	go func() {
		defer close(ch)
		// to starts a completely new hash after the full 32 bytes are used 
		currentRound := cursor / 32
		// The position to start reading the HMAC digest from
		currentRoundCursor := cursor % 32
		bytesGenerated := 0
		for bytesGenerated < count {
            // generate hash from input
			var b []byte = []byte(serverSeed)
			hmac := hmac.New(sha256.New, b)
            msg := fmt.Sprintf("%s:%s:%d", clientSeed, strconv.Itoa(nonce), currentRound)
			hmac.Write([]byte(msg))
			buffer := hmac.Sum(nil)

            // send hash to channel, 1 byet at a tiem
			for currentRoundCursor < 32 {
				ch <- buffer[currentRoundCursor]
				currentRoundCursor++
				bytesGenerated++
			}
            // Hash depleted. Reset cursor and re generate hash from a new `currentRound`
			currentRoundCursor = 0
			currentRound++
		}
	}()
	return ch
}

func (r RandomGenerator) GenerateFloats(serverSeed, clientSeed string, nonce, cursor, count int) ([]float64, error) {
	if count < 0 {
		return []float64{}, errors.New("count paramter should be greater than 0")
	}
	rng := byteGenerator(serverSeed, clientSeed, nonce, cursor, count * 4)
	byteSet := make([]byte, 0, count*4)
	// aggregate to sets of 4 bytes for a single random float
	for len(byteSet) < (count * 4) {
		b := <-rng
		byteSet = append(byteSet, b)
	}

	floats := make([]float64, count)
	for i := range floats {
		chunk := byteSet[i*4 : (i+1)*4]
		var value uint32
		// big endian so that the most significant bit is stored first, to produce large values from the "similar" chunks
		err := binary.Read(bytes.NewBuffer(chunk), binary.BigEndian, &value)
		if err != nil {
			return nil, err
		}
		// divide by 2 ** 32 to get value between 0 and 1
		floats[i] = float64(value) / (1 << 32)
	}
	return floats, nil
}
```

To generate a random numbers the call is simply this:

```go
randFloat, err := b.RNG.GenerateFloats("server seed", "client seed", 120, 0, 1)
```

To show that the output is a uniformly distributed set of floats between 0 and 1. Running the above command in a loop incrementing the nonce each time produced the below distribution: